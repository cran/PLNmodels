<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="PLN team" />

<meta name="date" content="2022-08-25" />

<title>Data importation in PLNmodels</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">
/* for pandoc --citeproc since 2.11 */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Data importation in PLNmodels</h1>
<h4 class="author">PLN team</h4>
<h4 class="date">2022-08-25</h4>


<div id="TOC">
<ul>
<li><a href="#preliminaries" id="toc-preliminaries">Preliminaries</a></li>
<li><a href="#format-description" id="toc-format-description">Format
description</a></li>
<li><a href="#computing-offsets" id="toc-computing-offsets">Computing
offsets</a></li>
<li><a href="#building-data-frame-using-prepare_data" id="toc-building-data-frame-using-prepare_data">Building data frame
using <code>prepare_data</code></a></li>
<li><a href="#importing-data-from-biom-and-phyloseq-objects-using-prepare_data_from_phyloseqbiom" id="toc-importing-data-from-biom-and-phyloseq-objects-using-prepare_data_from_phyloseqbiom">Importing
data from biom and phyloseq objects using
<code>prepare_data_from_[phyloseq|biom]</code></a>
<ul>
<li><a href="#reading-from-a-biom-file" id="toc-reading-from-a-biom-file">Reading from a biom file</a></li>
<li><a href="#reading-from-a-phyloseq-class-object" id="toc-reading-from-a-phyloseq-class-object">Reading from a
phyloseq-class object</a></li>
</ul></li>
<li><a href="#mathematical-details-about-the-offsets" id="toc-mathematical-details-about-the-offsets">Mathematical details
about the offsets</a>
<ul>
<li><a href="#total-sum-scaling" id="toc-total-sum-scaling">Total Sum
Scaling</a></li>
<li><a href="#cumulative-sum-scaling" id="toc-cumulative-sum-scaling">Cumulative Sum Scaling</a></li>
<li><a href="#relative-log-expression" id="toc-relative-log-expression">Relative Log Expression</a></li>
<li><a href="#geometric-mean-of-pairwise-ratio" id="toc-geometric-mean-of-pairwise-ratio">Geometric Mean of Pairwise
Ratio</a></li>
<li><a href="#wrench-normalisation" id="toc-wrench-normalisation">Wrench
normalisation</a></li>
</ul></li>
<li><a href="#references" id="toc-references">References</a></li>
</ul>
</div>

<div id="preliminaries" class="section level2">
<h2>Preliminaries</h2>
<p>This vignette documents the data format used in
<strong>PLNmodel</strong> by <code>PLN</code> and its variants. It also
shows how to create an object in the proper format for further analyses
from (i) tabular data, (ii) biom-class objects and (iii) phyloseq-class
objects.</p>
</div>
<div id="format-description" class="section level2">
<h2>Format description</h2>
<p>We illustrate the format using trichoptera data set, a full
description of which can be found in <a href="Trichoptera.html">the
corresponding vignette</a>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(PLNmodels)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(trichoptera)</span></code></pre></div>
<p>The trichoptera data set is a list made of two data frames:
<code>Abundance</code> (hereafter referred to as the <em>counts</em>)
and <code>Covariate</code> (hereafter the <em>covariates</em>).</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(trichoptera, <span class="at">max.level =</span> <span class="dv">1</span>)</span></code></pre></div>
<pre><code>## List of 2
##  $ Abundance:&#39;data.frame&#39;:   49 obs. of  17 variables:
##  $ Covariate:&#39;data.frame&#39;:   49 obs. of  7 variables:</code></pre>
<p>The covariates include, among others, the wind, pressure and
humidity.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(trichoptera<span class="sc">$</span>Covariate)</span></code></pre></div>
<pre><code>## [1] &quot;Temperature&quot;   &quot;Wind&quot;          &quot;Pressure&quot;      &quot;Humidity&quot;     
## [5] &quot;Cloudiness&quot;    &quot;Precipitation&quot; &quot;Group&quot;</code></pre>
<p>In the PLN framework, we model the counts from the covariates, let’s
say wind and pressure, using a Poisson Log-Normal model. Most models in
R use the so-called <em>formula interface</em> and it would thus be
natural to write something like</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">PLN</span>(Abundance <span class="sc">~</span> Wind <span class="sc">+</span> Pressure, <span class="at">data =</span> trichoptera)</span></code></pre></div>
<p>Unfortunately and unlike many generalized linear models, the response
in PLN is intrinsically <strong>multivariate</strong>: it has 17
dimensions in our example. The left hand side (LHS) must encode a
multivariate response across multiple samples, using a 2D-array (e.g. a
matrix or a data frame).</p>
<p>We must therefore prepare a data structure where
<code>Abundance</code> refers to a count <em>matrix</em> whereas
<code>Wind</code> and <code>Pressure</code> refer to <em>vectors</em>
before feeding it to <code>PLN</code>. That’s the purpose of
<code>prepare_data</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>trichoptera2 <span class="ot">&lt;-</span> <span class="fu">prepare_data</span>(<span class="at">counts     =</span> trichoptera<span class="sc">$</span>Abundance, </span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>                             <span class="at">covariates =</span> trichoptera<span class="sc">$</span>Covariate)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(trichoptera2)</span></code></pre></div>
<pre><code>## &#39;data.frame&#39;:    49 obs. of  9 variables:
##  $ Abundance    : num [1:49, 1:17] 0 0 0 0 0 0 0 0 0 0 ...
##   ..- attr(*, &quot;dimnames&quot;)=List of 2
##   .. ..$ : chr [1:49] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...
##   .. ..$ : chr [1:17] &quot;Che&quot; &quot;Hyc&quot; &quot;Hym&quot; &quot;Hys&quot; ...
##  $ Temperature  : num  18.7 19.8 22 23 22.5 23.9 15 17.2 15.4 14.1 ...
##  $ Wind         : num  -2.3 -2.7 -0.7 2.3 2.3 -2 -4.7 -1 -2.7 -3.7 ...
##  $ Pressure     : num  998 1000 997 991 990 ...
##  $ Humidity     : num  60 63 73 71 62 64 93 84 88 75 ...
##  $ Cloudiness   : num  19 0 6 81 50 50 100 19 69 6 ...
##  $ Precipitation: num  0 0 0 0 0 0 1.6 0 1.6 0 ...
##  $ Group        : Factor w/ 12 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
##  $ Offset       : num  29 13 38 192 79 18 8 34 12 4 ...</code></pre>
<p>If you look carefully, you can notice a few difference between
<code>trichoptera</code> and <code>trichoptera2</code>:</p>
<ul>
<li>the first is a <code>list</code> whereas the second is a
<code>data.frame</code><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>;</li>
<li><code>Abundance</code> is a matrix-column of
<code>trichoptera2</code> that you can extract using the usual functions
<code>[</code> and <code>[[</code> to retrieve the count matrix;</li>
<li><code>trichoptera2</code> has an additional <code>Offset</code>
column (more on that later).</li>
</ul>
</div>
<div id="computing-offsets" class="section level2">
<h2>Computing offsets</h2>
<p>It is common practice when modeling count data to introduce an offset
term to control for different sampling efforts, exposures, baselines,
etc. The <em>proper way</em> to compute sample-specific offsets in still
debated and may vary depending on the field. There are nevertheless a
few popular methods:</p>
<ul>
<li>Total Sum Scaling (TSS), where the offset of a sample is the total
count in that sample</li>
<li>Cumulative Sum Scaling (CSS), introduced in <span class="citation">(<a href="#ref-CSS" role="doc-biblioref">Paulson et al.
2013</a>)</span>, where the offset of a sample if the cumulative sum of
counts in that sample, up to a quantile determined in a data driven
way.</li>
<li>Relative Log-Expression (RLE), implemented in <span class="citation">(<a href="#ref-DESeq2" role="doc-biblioref">Anders and
Huber 2010</a>)</span>, where all samples are used to compute a
reference sample, each sample is compared to the reference sample using
log-ratios and the offset is the median log-ratio.</li>
<li>Geometric Mean of Pairwise Ratio (GMPR), introduced in <span class="citation">(<a href="#ref-GMPR" role="doc-biblioref">Chen et al.
2018</a>)</span> where each sample is compared to each other to compute
a median log-ratio and the offset of a sample is the geometric means of
those pairwise ratios.</li>
<li>Wrench, introduced in <span class="citation">(<a href="#ref-Kumar2018" role="doc-biblioref">Kumar et al. 2018</a>)</span>
and fully implemented in the <a href="http://bioconductor.org/packages/release/bioc/html/Wrench.html">Wrench
package</a>, where all samples are used to compute reference proportions
and each sample is compared to the reference using ratios (and
<strong>not log-ratios</strong>) of proportions to compute compositional
correction factors. In that case, the offset is the product of
(geometrically centered) compositional factors and (geometrically
centered) depths.</li>
</ul>
<p>Each of these offset be computed from a counts matrix using the
<code>compute_offset</code> function and changing its
<code>offset</code> argument:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="do">## same as compute_offset(trichoptera$Abundance, offset = &quot;TSS&quot;)</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">compute_offset</span>(trichoptera<span class="sc">$</span>Abundance) </span></code></pre></div>
<pre><code>##    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16 
##   29   13   38  192   79   18    8   34   12    4    4    3   49   33  600  172 
##   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31   32 
##   58   51   56  127   35   13   17    3   27   40   44    8    9 1599 2980   88 
##   33   34   35   36   37   38   39   40   41   42   43   44   45   46   47   48 
##  135  327   66   90   63   15   14   20   70   53   95   43   62  149   16   31 
##   49 
##   86</code></pre>
<p>In this particular example, the counts are too sparse and
sophisticated offset methods all fail (numeric output hidden)</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">compute_offset</span>(trichoptera<span class="sc">$</span>Abundance, <span class="st">&quot;CSS&quot;</span>)</span></code></pre></div>
<pre><code>## Warning in offset_function(counts, ...): Some samples only have 1 positive
## values. Can&#39;t compute quantiles and fall back to TSS normalization</code></pre>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">compute_offset</span>(trichoptera<span class="sc">$</span>Abundance, <span class="st">&quot;RLE&quot;</span>)</span></code></pre></div>
<pre><code>## Warning in offset_function(counts, ...): Because of high sparsity, some samples
## have null or infinite offset.</code></pre>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">compute_offset</span>(trichoptera<span class="sc">$</span>Abundance, <span class="st">&quot;GMPR&quot;</span>)</span></code></pre></div>
<p>We can mitigate this problem for the RLE offset by adding
pseudocounts to the counts although doing so has its own drawbacks.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">compute_offset</span>(trichoptera<span class="sc">$</span>Abundance, <span class="st">&quot;RLE&quot;</span>, <span class="at">pseudocounts =</span> <span class="dv">1</span>)</span></code></pre></div>
<pre><code>##         1         2         3         4         5         6         7         8 
## 0.9186270 0.8349121 0.8570257 0.9186270 0.9186270 0.8349121 0.8192245 0.8570257 
##         9        10        11        12        13        14        15        16 
## 0.7322797 0.7322797 0.6321923 0.6321923 0.9240361 0.9186270 1.3788037 0.9240361 
##        17        18        19        20        21        22        23        24 
## 0.9186270 0.9240361 0.9240361 1.7140514 0.8908577 0.8570257 0.8349121 0.6321923 
##        25        26        27        28        29        30        31        32 
## 0.9240361 0.9240361 0.9186270 0.8570257 0.8349121 2.7721084 3.2934218 0.9584503 
##        33        34        35        36        37        38        39        40 
## 1.0406547 0.9584503 0.9584503 0.9186270 0.9584503 0.8908577 0.8349121 0.7322797 
##        41        42        43        44        45        46        47        48 
## 0.9240361 0.9240361 0.9584503 0.9584503 1.2643846 1.7140514 0.8233555 0.8908577 
##        49 
## 0.9186270</code></pre>
<p>A better solution consists in using only positive counts to compute
the offsets:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">compute_offset</span>(trichoptera<span class="sc">$</span>Abundance, <span class="st">&quot;RLE&quot;</span>, <span class="at">type =</span> <span class="st">&quot;poscounts&quot;</span>)</span></code></pre></div>
<pre><code>##         1         2         3         4         5         6         7         8 
## 0.5631099 0.9462046 0.8299806 0.9462046 0.6460415 0.5756774 0.6308031 0.4947789 
##         9        10        11        12        13        14        15        16 
## 0.7988730 0.3574190 0.2207270 0.1260525 0.8051707 0.7289732 1.5591914 1.1850090 
##        17        18        19        20        21        22        23        24 
## 0.6389431 1.0000000 1.4606879 1.8224330 0.8403498 0.3942114 0.4058586 0.1997183 
##        25        26        27        28        29        30        31        32 
## 0.6286560 0.5631099 0.8777257 0.3440303 0.2504662 2.7086423 2.5800932 1.4584997 
##        33        34        35        36        37        38        39        40 
## 2.6050843 4.5898981 1.2185072 1.2616062 0.8823673 0.6250713 0.3950030 0.5631099 
##        41        42        43        44        45        46        47        48 
## 1.4511384 1.0000000 0.9462046 1.0882448 1.0000000 1.0631099 0.4621924 0.7900060 
##        49 
## 1.0672361</code></pre>
<p>Finally, we can use wrench to compute the offsets:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">compute_offset</span>(trichoptera<span class="sc">$</span>Abundance, <span class="st">&quot;Wrench&quot;</span>)</span></code></pre></div>
<pre><code>##  [1]  0.41269451  0.17385897  0.31925785  0.70682391  0.44749382  0.20676142
##  [7]  0.10226641  0.21204241  0.09228293  0.03919178  0.03946910  0.02295077
## [13] 24.18096281  1.54038084  3.95187144  0.80172207 10.52136472  4.55854738
## [19]  0.46968859 51.88528943  0.32803605  0.14764973  4.13635353  0.03152826
## [25]  1.63626578  0.53769290  0.38482355  0.62689594  0.08030685 83.87692476
## [31] 33.40810265  0.75508731  1.05809625  1.18385013  0.58657751  0.43005272
## [37]  4.79925224  0.18381986  0.16078594  0.18490773  4.25999137  5.46689591
## [43]  0.60139850  7.56594658  9.89766712 33.73727074  0.74264459 29.13747796
## [49] 47.12017975</code></pre>
</div>
<div id="building-data-frame-using-prepare_data" class="section level2">
<h2>Building data frame using <code>prepare_data</code></h2>
<p>We’ll already learned that <code>prepare_data</code> can join counts
and covariates into a single data.frame. It can also compute offset
through <code>compute_offset</code> and does so by default with
<code>offset = &quot;TSS&quot;</code>, hence the <code>Offset</code> column in
<code>trichoptera2</code>. You can change the offset method and provide
additional arguments that will passed on to
<code>compute_offset</code>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(<span class="fu">prepare_data</span>(trichoptera<span class="sc">$</span>Abundance, </span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>             trichoptera<span class="sc">$</span>Covariate, </span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>             <span class="at">offset =</span> <span class="st">&quot;RLE&quot;</span>, <span class="at">pseudocounts =</span> <span class="dv">1</span>))</span></code></pre></div>
<pre><code>## &#39;data.frame&#39;:    49 obs. of  9 variables:
##  $ Abundance    : num [1:49, 1:17] 0 0 0 0 0 0 0 0 0 0 ...
##   ..- attr(*, &quot;dimnames&quot;)=List of 2
##   .. ..$ : chr [1:49] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...
##   .. ..$ : chr [1:17] &quot;Che&quot; &quot;Hyc&quot; &quot;Hym&quot; &quot;Hys&quot; ...
##  $ Temperature  : num  18.7 19.8 22 23 22.5 23.9 15 17.2 15.4 14.1 ...
##  $ Wind         : num  -2.3 -2.7 -0.7 2.3 2.3 -2 -4.7 -1 -2.7 -3.7 ...
##  $ Pressure     : num  998 1000 997 991 990 ...
##  $ Humidity     : num  60 63 73 71 62 64 93 84 88 75 ...
##  $ Cloudiness   : num  19 0 6 81 50 50 100 19 69 6 ...
##  $ Precipitation: num  0 0 0 0 0 0 1.6 0 1.6 0 ...
##  $ Group        : Factor w/ 12 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
##  $ Offset       : num  0.919 0.835 0.857 0.919 0.919 ...</code></pre>
<p>Different communities use different standard for the count data where
samples are either or columns of the counts matrix.
<code>prepare_data</code> uses heuristics to guess the direction of the
counts matrix (or fail informatively doing so) and automatically
transpose it if needed.</p>
<p>Finally, <code>prepare_data</code> enforces sample-consistency
between the counts and the covariates and automatically trims away: -
samples for which only covariates or only counts are available; -
samples with no positive counts</p>
<p>For example, if we remove the first sample from the counts and the
last one from the covariates, we end up with 49 - 2 = 47 samples left,
as expected.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">nrow</span>(<span class="fu">prepare_data</span>(trichoptera<span class="sc">$</span>Abundance[<span class="sc">-</span><span class="dv">1</span>, ], <span class="do">## remove first sample</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>                  trichoptera<span class="sc">$</span>Covariate[<span class="sc">-</span><span class="dv">49</span>,]  <span class="do">## remove last sample</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>                  ))</span></code></pre></div>
<pre><code>## [1] 47</code></pre>
</div>
<div id="importing-data-from-biom-and-phyloseq-objects-using-prepare_data_from_phyloseqbiom" class="section level2">
<h2>Importing data from biom and phyloseq objects using
<code>prepare_data_from_[phyloseq|biom]</code></h2>
<p>Community composition data are quite popular in microbial ecology and
usually stored in flat files using the <a href="http://biom-format.org/">biom format</a> and/or imported in R as
phyloseq-class objects <span class="citation">(<a href="#ref-phyloseq" role="doc-biblioref">McMurdie 2013</a>)</span> using the Bioconductor <a href="https://joey711.github.io/phyloseq/">phyloseq</a> package.</p>
<!-- We provide helper functions to directly import data from a biom file (or biom-class object) and a phyloseq-class object.  -->
<p>We show here how to import data from a biom file (or biom-class
object) and form a phyloseq-class object.</p>
<div id="reading-from-a-biom-file" class="section level3">
<h3>Reading from a biom file</h3>
<p>Reading from a biom file requires the bioconductor package <a href="https://www.bioconductor.org/packages/release/bioc/html/biomformat.html">biomformat</a>.
This package is <strong>not</strong> a standard dependency of PLNmodels
and needs to be installed separately.</p>
<p>You can easily prepare your data from a biom file using the following
steps:</p>
<ul>
<li>read your biom file with <code>biomformat::read_biom()</code></li>
<li>extract the count table with
<code>biomformat::biom_data()</code></li>
<li>extract the covariates with
<code>biomformat::sample_metadata()</code> (or build your own)</li>
<li>feed them to <code>prepare_data</code></li>
</ul>
<p>as illustrated below:
<!-- Note that the covariates **must** be stored in the biom object as they are automatically extracted, reading a biom without covariates results in an error.  --></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="do">## If biomformat is not installed, uncomment the following lines</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="co"># if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) {</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="co">#   install.packages(&quot;BiocManager&quot;)</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="co"># }</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="co"># BiocManager::install(&quot;biomformat&quot;)</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(biomformat)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>biomfile <span class="ot">&lt;-</span> <span class="fu">system.file</span>(<span class="st">&quot;extdata&quot;</span>, <span class="st">&quot;rich_dense_otu_table.biom&quot;</span>, <span class="at">package =</span> <span class="st">&quot;biomformat&quot;</span>)</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>biom <span class="ot">&lt;-</span> biomformat<span class="sc">::</span><span class="fu">read_biom</span>(biomfile)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="do">## extract counts</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>counts <span class="ot">&lt;-</span> <span class="fu">as</span>(biomformat<span class="sc">::</span><span class="fu">biom_data</span>(biom), <span class="st">&quot;matrix&quot;</span>)</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span class="do">## extract covariates (or prepare your own)</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>covariates <span class="ot">&lt;-</span> biomformat<span class="sc">::</span><span class="fu">sample_metadata</span>(biom)</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a><span class="do">## prepare data</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>my_data <span class="ot">&lt;-</span> <span class="fu">prepare_data</span>(<span class="at">counts =</span> counts, <span class="at">covariates =</span> covariates)</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(my_data)</span></code></pre></div>
</div>
<div id="reading-from-a-phyloseq-class-object" class="section level3">
<h3>Reading from a phyloseq-class object</h3>
<p>Likewise, preparing data from a phyloseq-class object requires the
bioconductor package <a href="https://www.bioconductor.org/packages/release/bioc/html/phyloseq.html">phyloseq</a>.
This package is <strong>not</strong> a standard dependency of PLNmodels
and needs to be installed separately.</p>
<p>You can easily prepare your data from a phyloseq object using the
following steps:</p>
<ul>
<li>extract the count table with <code>phyloseq::otu_table()</code></li>
<li>extract the covariates with <code>phyloseq::sample_data()</code> (or
build your own)</li>
<li>feed them to <code>prepare_data</code></li>
</ul>
<p>as illustrated below:</p>
<!-- Note that the covariates **must** be stored in the phyloseq-class object as they are automatically extracted, importing a phyloseq object with no `sample_data` component results in an error.  -->
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="do">## If biomformat is not installed, uncomment the following lines</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="co"># if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) {</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="co">#   install.packages(&quot;BiocManager&quot;)</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="co"># }</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="co"># BiocManager::install(&quot;phyloseq&quot;)</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(phyloseq)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">&quot;enterotype&quot;</span>)</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="do">## extract counts</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>counts <span class="ot">&lt;-</span> <span class="fu">as</span>(phyloseq<span class="sc">::</span><span class="fu">otu_table</span>(enterotype), <span class="st">&quot;matrix&quot;</span>)</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="do">## extract covariates (or prepare your own)</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>covariates <span class="ot">&lt;-</span> phyloseq<span class="sc">::</span><span class="fu">sample_data</span>(enterotype)</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a><span class="do">## prepare data</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>my_data <span class="ot">&lt;-</span> <span class="fu">prepare_data</span>(<span class="at">counts =</span> counts, <span class="at">covariates =</span> covariates)</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(my_data)</span></code></pre></div>
</div>
</div>
<div id="mathematical-details-about-the-offsets" class="section level2">
<h2>Mathematical details about the offsets</h2>
<p>We detail here the mathematical background behind the various offsets
and the way they are computed. Note <span class="math inline">\(\mathbf{Y} = (Y_{ij})\)</span> the counts matrix
where <span class="math inline">\(Y_{ij}\)</span> is the count of
species <span class="math inline">\(j\)</span> in sample <span class="math inline">\(i\)</span>. Assume that there are <span class="math inline">\(p\)</span> species and <span class="math inline">\(n\)</span> samples in total. The offset of sample
<span class="math inline">\(i\)</span> is noted <span class="math inline">\(O_i\)</span> and computed in the following
way.</p>
<div id="total-sum-scaling" class="section level3">
<h3>Total Sum Scaling</h3>
<p>Offsets are simply the total counts of a sample (frequently called
depths in the metabarcoding literature): <span class="math display">\[
O_i = \sum_{j=1}^p Y_{ij}
\]</span></p>
</div>
<div id="cumulative-sum-scaling" class="section level3">
<h3>Cumulative Sum Scaling</h3>
<p>Positive counts are used to compute sample-specific quantiles <span class="math inline">\(q_i^l\)</span> and cumulative sums <span class="math inline">\(s_i^l\)</span> defined as <span class="math display">\[
q_i^l = \min \{q \text{ such that } \sum_j 1_{Y_{ij} \leq q} \geq l
\sum_j 1_{Y_{ij} &gt; 0} \} \qquad s_i^l = \sum_{j: Y_{ij} \leq q_i^l}
Y_{ij}
\]</span> The sample-specific quantiles are then used to compute
reference quantiles defined as <span class="math inline">\(q^l =
\text{median} \{q^i_l\}\)</span> and median average deviation around the
quantile <span class="math inline">\(q^l\)</span> as <span class="math inline">\(d^l = \text{median} |q_i^l - q^l|\)</span>. The
method then searches for the smallest quantile <span class="math inline">\(l\)</span> for which it detects instability,
defined as large relative increase in the <span class="math inline">\(d^l\)</span>. Formally, <span class="math inline">\(\hat{l}\)</span> is the smallest <span class="math inline">\(l\)</span> satisfying <span class="math inline">\(\frac{d^{l+1} - d^l}{d^l} \geq 0.1\)</span>. The
scaling sample-specific offset are then chosen as: <span class="math display">\[
O_i = s_i^{\hat{l}} / \text{median}_i \{ s_i^{\hat{l}} \}
\]</span> Dividing by the median of the <span class="math inline">\(s_i^{\hat{l}}\)</span> ensures that offsets are
centered around <span class="math inline">\(1\)</span> and compare sizes
differences with respect to the reference sample. Note also that the
reference quantiles <span class="math inline">\(q^l\)</span> can be
computed using either the median (default, as in the original <span class="citation">Paulson et al. (<a href="#ref-CSS" role="doc-biblioref">2013</a>)</span> paper) or the mean, by specifying
<code>reference = mean</code>, as implemented in
<code>metagenomeseq</code>.</p>
</div>
<div id="relative-log-expression" class="section level3">
<h3>Relative Log Expression</h3>
<p>A reference sample <span class="math inline">\((q_j)_j\)</span> is
first built by computing the geometric means of each species count:
<span class="math display">\[
q_j = \exp \left( \frac{1}{n} \sum_{i} \log(Y_{ij})\right)
\]</span> Each sample is then compared to the reference sample to
compute one ratio per species and the final offset <span class="math inline">\(O_i\)</span> is the median of those ratios: <span class="math display">\[
O_i = \text{median}_j \frac{Y_{ij}}{q_j}
\]</span> The method fails when no species is shared across all sample
(as all <span class="math inline">\(q_j\)</span> are then <span class="math inline">\(0\)</span>) or when a sample shares less than 50%
of species with the reference (in which case the median of the ratios
may be null or infinite). The problem can be alleviated by adding
pseudocounts to the <span class="math inline">\(c_{ij}\)</span> with
<code>pseudocounts = 1</code> or using positive counts in the
computations (<code>type = &quot;poscounts&quot;</code>)</p>
</div>
<div id="geometric-mean-of-pairwise-ratio" class="section level3">
<h3>Geometric Mean of Pairwise Ratio</h3>
<p>This method is similar to RLE but does create a reference sample.
Instead, each sample is compared to each other to compute a median ratio
(similar to RLE) <span class="math display">\[
r_{ii&#39;} = {\text{median}}_{j: Y_{ij}.Y_{i&#39;j} &gt; 0}
\frac{Y_{ij}}{Y_{i&#39;j}}
\]</span> The offset is then taken as the median of all the <span class="math inline">\(r_{ii&#39;}\)</span>: <span class="math display">\[
O_i = \text{median}_{i&#39; != i} r_{ii&#39;}
\]</span> The method fails when there is only one sample in the data set
or when a sample shares no species with any other.</p>
</div>
<div id="wrench-normalisation" class="section level3">
<h3>Wrench normalisation</h3>
<p>This method is fully detailed in <span class="citation">Kumar et al.
(<a href="#ref-Kumar2018" role="doc-biblioref">2018</a>)</span> and we
only provide a barebone implementation corresponding to the defaults
parameters of <code>Wrench::wrench()</code>. Assume that samples belong
to <span class="math inline">\(K\)</span> discrete groups and note <span class="math inline">\(g_i\)</span> the group of sample <span class="math inline">\(i\)</span>. Wrench is based on the following
(simplified) log-normal model for counts: <span class="math display">\[
Y_{ij} \sim \pi_{ij} \delta_0 + (1 - \pi_{ij})\log\mathcal{N}(\mu_{ij},
\sigma^2_j)
\]</span> where the <span class="math inline">\(Y_{ij}\)</span> are
independent and the mean <span class="math inline">\(\mu_{ij}\)</span>
is decomposed as: <span class="math display">\[
\mu_{ij} = \underbrace{\log{p_{0j}}}_{\text{log-ref. prop.}}
+  \underbrace{\log{d_i}}_{\text{log-depth}} +
\underbrace{\log{\zeta_{0g_i}}}_{\text{log effect of group } g_i} +
\underbrace{a_{i}}_{\text{(f|m)ixed effect}} +
\underbrace{b_{ij}}_{\text{mixed effects}}
\]</span> where the random effects are independents centered gaussian
and the depths is the total sum of counts: <span class="math display">\[
\begin{align*}
d_i &amp; = \sum_{j=1}^p c_{ij} \\
b_{ij} &amp; \sim \mathcal{N}(0, \eta^2_{g_i}) \\
\end{align*}
\]</span></p>
<p>The <strong>net</strong> log fold change <span class="math inline">\(\theta_{ij}\)</span> of the <strong>proportion
ratio</strong> <span class="math inline">\(r_{ij} = c_{ij} / d_i
p_{0j}\)</span> of species <span class="math inline">\(j\)</span>
relative to the reference is <span class="math inline">\(\log(\theta_{ij}) \overset{\Delta}{=}
\mathbb{E}[\log(r_{ij}) | a_i, b_{ij}] = \log{\zeta_{0g_i}} + a_i +
b_{ij}\)</span>. We can decompose it as <span class="math inline">\(\theta_{ij} = \Lambda_i^{-1} v_{ij}\)</span> where
<span class="math inline">\(\Lambda_i^{-1}\)</span> is the
<em>compositional correction factor</em> and <span class="math inline">\(v_{ij}\)</span> is the fold change of <strong>true
abundances</strong>.</p>
<p>With the above notations, the net fold change compounds both the fold
change of true abundances and the compositional correction factors. With
the assumption that the <span class="math inline">\(b_{ij}\)</span> are
centered, <span class="math inline">\(\log(\hat{\Lambda}_i)\)</span> can
be estimated through a robust average of the <span class="math inline">\(\hat{\theta}_{ij}\)</span>, which can themselves
be computed from the log-ratio of proportions.</p>
<p>We detail here how the different parameters and/or effects are
estimated.</p>
<ul>
<li>The reference proportions <span class="math inline">\(p_{0j}\)</span> are constructed as averages of the
sample proportions <span class="math inline">\(p_{ij}\)</span> and the
ratio are derived from both quantities <span class="math display">\[
p_{ij} = \frac{Y_{ij}}{\sum_{j=1}^p Y_{ij}} \qquad p_{0j} = \frac{1}{n}
\sum_{i=1}^n p_{ij} \qquad r_{ij} = \frac{p_{ij}}{p_{0j}}
\]</span></li>
<li>The probabilities of absence <span class="math inline">\(\pi_{ij}\)</span> are estimated by fitting the
following Bernoulli models: <span class="math display">\[
1_{\{Y_{ij} = 0\}} \sim \mathcal{B}(\pi_{j}^{d_i})
\]</span> and setting <span class="math inline">\(\hat{\pi}_{ij} =
\hat{\pi}^{d_i}\)</span></li>
<li>The species variances <span class="math inline">\(\sigma^2_j\)</span> are estimated by fitting the
following linear model (with no zero-inflation component) <span class="math display">\[
\log Y_{ij} \sim \log(d_i) + \mu_{g_i} + \mathcal{N}(0, \sigma^2_j)
\]</span> Note that in the original <code>Wrench::wrench()</code>, the
log depth <span class="math inline">\(\log(d_i)\)</span> is used as
predictor but I believe it makes more sense to use it an offset.</li>
<li>set the group proportions <span class="math inline">\(p_{gj}\)</span> and group ratios <span class="math inline">\(r_{gj}\)</span> to: <span class="math display">\[
p_{gj} = \frac{\sum_{i : g_i = g} Y_{ij}}{\sum_{j, i : g_i = g} Y_{ij}}
\qquad r_{gj} = \frac{p_{gj}}{p_{0j}}
\]</span></li>
<li>Estimate the location and dispersion parameters as: <span class="math display">\[
\hat{\zeta}_{0g} = \frac{\sum_{j=1}^p r_{gj}}{p}
\qquad
\log{r_{g.}} = \frac{\sum_{j: r_{gj} \neq 1} \log{r_{gj}}}{\sum_{j:
r_{gj} \neq 0} 1}   
\qquad
\hat{\eta}_{g}^2 = \frac{\sum_{j: r_{gj} \neq 1} (\log{r_{gj}} -
\log{r_{g.}})^2}{\sum_{j: r_{gj} \neq 0} 1}
\]</span></li>
<li>Estimate the mixed effects as shrunken (and scaled) averages of the
ratios <span class="math display">\[
\hat{a}_i = \frac{\sum_{j = 1}^p \frac{1}{\hat{\eta}^2_{g_i} +
\hat{\sigma}^2_j} (\log{r_{ij}} - \log{\hat{\zeta}_{0g_i}})}{\sum_{j =
1}^p \frac{1}{\hat{\eta}^2_{g_i} + \hat{\sigma}^2_j}}
\qquad
\hat{b}_{ij} = \frac{\hat{\eta}^2_{g_i}}{\hat{\eta}^2_{g_i} +
\hat{\sigma}^2_j} \left( \log{r_{ij}} - \log\hat{\zeta}_{0g_i} -
\hat{a}_i\right)
\]</span></li>
<li>Estimate the regularized ratios as: <span class="math display">\[
\hat{\theta}_{ij} = \exp\left( \log\hat{\zeta}_{0g_i} + \hat{a}_i +
\hat{b}_{ij} \right)
\]</span></li>
<li>Estimate the compositional correction factors as (weighted) means of
the regularized (and possibly corrected) ratios: <span class="math display">\[
\hat{\Lambda}_i =
\begin{cases}
\sum_{j = 1}^p \hat{\theta}_{ij} \bigg/ p&amp; \text{ if type =
&quot;simple&quot;} \\
\sum_{j = 1}^p \hat{\theta}_{ij} e^{-\hat{\sigma}_j^2 / 2} /  w_{ij}
\bigg/ \sum_{j=1}^p 1/w_{ij}  &amp; \text{ if type = &quot;wrench&quot;}
\\
\end{cases}
\]</span> where <span class="math inline">\(w_{ij} = (1 -
\hat{\pi}_{ij})(\hat{\pi}_{ij} + e^{\hat{\sigma}_j^2 + \hat{\eta}_i^2} -
1)\)</span>. The correction term <span class="math inline">\(e^{\hat{\sigma}_j^2 / 2}\)</span> arises from the
relation <span class="math inline">\(\mathbb{E}[r_{ij} | r_{ij} &gt; 0]
= \theta_{ij} e^{\sigma_j^2/2}\)</span> and the weight <span class="math inline">\(w_{ij}\)</span> are marginal variances: <span class="math inline">\(\mathbb{V}[r_{ij}] = w_{ij}\)</span>.</li>
</ul>
<p>The offsets are then the product of compositional correction factors
and depths: <span class="math display">\[
O_i = \frac{\hat{\Lambda}_i}{(\prod_{i = 1}^n \hat{\Lambda}_i)^{1/n}}
\times \frac{d_i}{(\prod_{i = 1}^n d_i)^{1/n}}
\]</span></p>
</div>
</div>
<div id="references" class="section level2 unnumbered">
<h2 class="unnumbered">References</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-DESeq2" class="csl-entry">
Anders, Simon, and Wolfgang Huber. 2010. <span>“Differential Expression
Analysis for Sequence Count Data.”</span> <em>Genome Biology</em> 11
(10): R106. <a href="https://doi.org/10.1186/gb-2010-11-10-r106">https://doi.org/10.1186/gb-2010-11-10-r106</a>.
</div>
<div id="ref-GMPR" class="csl-entry">
Chen, Li, James Reeve, Lujun Zhang, Shengbing Huang, Xuefeng Wang, and
Jun Chen. 2018. <span>“GMPR: A Robust Normalization Method for
Zero-Inflated Count Data with Application to Microbiome Sequencing
Data.”</span> <em>PeerJ</em> 6 (April): e4600. <a href="https://doi.org/10.7717/peerj.4600">https://doi.org/10.7717/peerj.4600</a>.
</div>
<div id="ref-Kumar2018" class="csl-entry">
Kumar, M. Senthil, Eric V. Slud, Kwame Okrah, Stephanie C. Hicks,
Sridhar Hannenhalli, and Héctor Corrada Bravo. 2018. <span>“Analysis and
Correction of Compositional Bias in Sparse Sequencing Count
Data.”</span> <em><span>BMC</span> Genomics</em> 19 (1). <a href="https://doi.org/10.1186/s12864-018-5160-5">https://doi.org/10.1186/s12864-018-5160-5</a>.
</div>
<div id="ref-phyloseq" class="csl-entry">
McMurdie, Paul J. AND Holmes. 2013. <span>“Phyloseq: An r Package for
Reproducible Interactive Analysis and Graphics of Microbiome Census
Data.”</span> <em>PLoS ONE</em> 8 (4): e61217. <a href="https://doi.org/10.1371/journal.pone.0061217">https://doi.org/10.1371/journal.pone.0061217</a>.
</div>
<div id="ref-CSS" class="csl-entry">
Paulson, Joseph N, O. Colin Stine, Héctor Corrada Bravo, and Mihai Pop.
2013. <span>“Differential Abundance Analysis for Microbial Marker-Gene
Surveys.”</span> <em>Nat Methods</em> 10 (September): 1200–1202. <a href="https://doi.org/10.1038/nmeth.2658">https://doi.org/10.1038/nmeth.2658</a>.
</div>
</div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr />
<ol>
<li id="fn1"><p>although a <code>data.frame</code> is technically a
<code>list</code><a href="#fnref1" class="footnote-back">↩︎</a></p></li>
</ol>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
